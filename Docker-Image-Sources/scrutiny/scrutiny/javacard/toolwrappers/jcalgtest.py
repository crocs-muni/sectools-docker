import os
import pathlib
from abc import ABC, abstractmethod
from typing import List, final

from overrides import overrides, EnforceOverrides

from scrutiny.config import Paths
from scrutiny.interfaces import ToolWrapper
from scrutiny.javacard.modules.algperformance import AlgPerformance
from scrutiny.javacard.modules.algvariable import AlgVariable
from scrutiny.javacard.modules.jcalgtest import JCAlgTestModule, \
    PerformanceResult, SupportResult
from scrutiny.utils import execute_cmd
from scrutiny.javacard.modules.algsupport import AlgSupport

SUPPORT_STRING = "ALGSUPPORT"
PERFORMANCE_STRING = "DATAFIXED"
VARIABLE_STRING = "DATADEPEND"

DISCARD = [
    "This file was generated by AlgTest utility",
    "This is very specific feature",
    "algorithm_name"
]

TEST_INFO = [
    "Tested and provided by",
    "Execution date",
    "AlgTest",
    "Used reader",
    "Card ATR",
    "Card name",
    "Card provider",
    "Used protocol",
    "High-power mode supported",
    "Package_AID_test",
    "JavaCard support version",
    "Total"
]


def install_jcalgtest_applet(force=False):
    """
    Installs JCAlgTest applet
    :param force: also remove previously installed JCAlgTest applets
    """
    if force:
        execute_cmd("java -jar " + Paths.GPPRO + " -uninstall " +
                    Paths.JCALGTEST_305)
    for applet in Paths.JCALGTEST_CAPS:
        cmd_line = "java -jar " + Paths.GPPRO + " -install " + applet
        if execute_cmd(cmd_line) == 0:
            break


def parse_common_line(module: JCAlgTestModule, line: str) -> bool:
    """
    Parses common lines found in all JCAlgTest output types
    :param line: parsed line
    :param module: JCAlgTest module
    :return True if line contained common data
    """

    if line == "" or ";" not in line \
            or any([d in line for d in DISCARD]):
        return True

    data = line.split(";")

    if any([line.startswith(info) for info in TEST_INFO]):
        module.test_info[data[0]] = data[1].strip()
        return True

    if line.startswith("JCSystem"):
        module.jcsystem[data[0]] = data[1]
        return True

    if line.startswith("APDU"):
        module.apdu[data[0]] = data[1]
        return True

    if line.startswith("CPLC"):
        module.cplc[data[0]] = data[1]
        return True

    return False


def parse_performance_block(lines: List[str], position: int,
                            result: PerformanceResult):
    """
    Parse performance block in JCAlgTest performance data

    Example of the parsed data:
    method name:; TYPE_DES LENGTH_DES ALG_DES_CBC_NOPAD Cipher_update()
    measurement config:;appletPrepareINS;31;appletMeasureINS;43;config;00...
    baseline measurements (ms):;154,00;151,00;152,00;152,00;151,00;
    baseline stats (ms):;avg:;152,00;min:;151,00;max:;154,00;
    operation raw measurements (ms):;986,00;989,00;989,00;988,00;988,00;
    operation stats (ms/op):;avg op:;19,76;min op:;19,72;max op:;19,78;
    operation info:;data length;256;total iterations;250;total invocations;250;
    """

    conf, base, base_stats, op, op_stats, op_info = \
        ([col.strip() for col in lines[position + i].split(";")]
         for i in range(1, 7))

    if conf[0] != "measurement config:":
        result.error = ";".join(conf)
        return

    result.prepare_ins = int(conf[2], 16)
    result.measure_ins = int(conf[4], 16)
    result.config = conf[6]

    if base[0] != "baseline measurements (ms):":
        result.error = ";".join(base)
        return

    result.baseline.extend([float(v.replace(",", ".")) for v in base[1:-1]])

    if base_stats[0] != "baseline stats (ms):":
        result.error = ";".join(base_stats)
        return

    # Implement control?

    if op[0] != "operation raw measurements (ms):":
        result.error = ";".join(op)
        return

    result.operation.extend([float(v.replace(",", ".")) for v in op[1:-1]])

    if op_stats[0] != "operation stats (ms/op):":
        result.error = ";".join(op_stats)
        return

    # Implement control?

    if op_info[0] != "operation info:":
        result.error = ";".join(op_stats)
        return

    result.data_length = int(op_info[2])
    result.iterations = int(op_info[4])
    result.invocations = int(op_info[6])


class JCAlgTest(ToolWrapper, ABC, EnforceOverrides):
    """SCRUTINY JCAlgTest ToolWrapper"""

    JCALGTEST_BIN = "java -jar " + Paths.JCALGTEST
    CAPS = Paths.JCALGTEST_CAPS

    def __init__(self, card_name, force_mode=False, install=True):
        super().__init__(card_name, force_mode)
        self.outfile = None
        if install:
            install_jcalgtest_applet()

    @final
    def find_outfile(self, search_string):
        """
        Find JCAlgTest output file
        :param search_string: JCAlgTest mode string
        """
        if self.outfile:
            return self.outfile
        for file in os.listdir(self.get_outpath("")):
            if search_string in file:
                self.outfile = file
        return self.outfile

    @abstractmethod
    def get_outfile(self):
        """
        Get JCAlgTest output file name
        :return: Output file name if it exists
        """

    @final
    def run_jcalgtest(self, args, search_string):
        """
        Run JCAlgTest
        :param args: JCAlgTest arguments
        :param search_string: JCAlgTest mode string
        :return: return code
        """
        cmd_line = self.JCALGTEST_BIN + " " + " ".join(args)
        if self.get_outfile():
            print("Skipping " + cmd_line + " (results found).")
            return 0

        retcode = execute_cmd(cmd_line)

        # if existing measurement is already present in results folder, replace it with newer one
        for file in os.listdir("./results/" + self.device_name + "/"):
            if search_string in file and self.device_name in file:
                dest = self.get_outpath(file)
                #os.replace(file, dest)
                self.outfile = file
                break

        return retcode

    @classmethod
    def parse_specific_lines(cls, line: str, module: JCAlgTestModule,
                             lines: List[str], position: int) -> None:
        """
        Parses lines from different types of JCAlgTest results
        :param line starting line
        :param module: JCAlgTest module
        :param lines: file content
        :param position: line to parse
        :return:
        """

    @classmethod
    @final
    def parse_loop(cls, module, filename) -> None:
        """Performs general parsing loop for JCAlgTest result files"""

        with open(filename, "r") as f:
            lines = f.readlines()

        for i, line in enumerate(lines):

            line = line.strip()

            if parse_common_line(module, line):
                continue

            cls.parse_specific_lines(line, module, lines, i)


class JCAlgTestSupport(JCAlgTest):
    """JCAlgTest support ToolWrapper"""
    @overrides
    def get_outfile(self):
        return self.find_outfile(SUPPORT_STRING)

    @overrides
    def run(self):
        return self.run_jcalgtest(['-fresh', '-op', 'ALG_SUPPORT_BASIC', '-cardname', self.device_name,
                                   '-outpath', './results/' + self.device_name + '/'], SUPPORT_STRING)

    @overrides
    def parse(self):
        alg_support = AlgSupport()
        modules = [alg_support]
        self.parse_loop(alg_support, self.get_outpath(self.outfile))
        return modules

    @classmethod
    @overrides
    def parse_specific_lines(cls, line: str, module: AlgSupport,
                             lines: List[str], position: int) -> None:

        result = SupportResult()
        data = [col.strip() for col in line.split(";")]

        if data[1] == "yes":
            result.support = True
        elif data[1] == "no":
            result.support = False
        else:
            result.error = data[1]
            result.support = False

        if len(data) >= 3 and data[2] != "":
            if "sec" in data[2]:
                data[2] = data[2].split(" ")[0]
            result.time_elapsed = float(data[2].replace(",", "."))
        if len(data) >= 6:
            result.persistent_memory = int(data[3])
            result.ram_deselect = int(data[4])
            result.ram_reset = int(data[5])

        if data[0] not in module.support:
            module.support[data[0]] = result


class JCAlgTestSupportExtended(JCAlgTest):
    """JCAlgTest extended support ToolWrapper"""

    @overrides
    def get_outfile(self):
        return self.find_outfile(SUPPORT_STRING)

    @overrides
    def run(self):
        return self.run_jcalgtest(['-fresh', '-op', 'ALG_SUPPORT_EXTENDED', '-cardname', self.device_name,
                                   '-outpath', './results/' + self.device_name + '/'], SUPPORT_STRING)

    @overrides
    def parse(self):
        return JCAlgTestSupport.parse(self)

    @classmethod
    @overrides
    def parse_specific_lines(cls, line: str, module: AlgSupport,
                             lines: List[str], position: int) -> None:
        return JCAlgTestSupport.parse_specific_lines(line, module, lines, position)


class JCAlgTestPerformance(JCAlgTest):
    """JCAlgTest performance ToolWrapper"""

    @overrides
    def get_outfile(self):
        return self.find_outfile(PERFORMANCE_STRING)

    @overrides
    def run(self):
        return self.run_jcalgtest([], PERFORMANCE_STRING)

    @overrides
    def parse(self):
        alg_performance = AlgPerformance()
        modules = [alg_performance]
        self.parse_loop(alg_performance, self.get_outpath(self.outfile))
        return modules

    @classmethod
    @overrides
    def parse_specific_lines(cls, line: str, module: JCAlgTestModule,
                             lines: List[str], position: int) -> None:

        if not line.startswith("method name:"):
            return

        result = PerformanceResult()
        key = line.split(";")[1].strip()
        module.add_result(key, result)

        parse_performance_block(lines, position, result)


class JCAlgTestVariable(JCAlgTestPerformance):
    """JCAlgTest variable performance ToolWrapper"""

    @overrides
    def get_outfile(self):
        return self.find_outfile(VARIABLE_STRING)

    @overrides
    def run(self):
        return self.run_jcalgtest([], VARIABLE_STRING)

    @overrides
    def parse(self):
        alg_variable = AlgVariable()
        modules = [alg_variable]
        self.parse_loop(alg_variable, self.get_outpath(self.outfile))
        return modules
